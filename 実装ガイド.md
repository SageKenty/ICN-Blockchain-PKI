# データ構造
データを送信する際、先行研究の通りjson化して、そこからそのJSONをUTF-8に変換して送信。受け取った相手はそれを元にJSONに戻し、データ操作をするという流れなのだが、ここがややこしく詰まりの原因になるかもしれないので、事前にまとめておく。

## 1.基本法則
基本法則は、バイト列で生成される署名や公開鍵はhex形式に変換し、入れる。名前空間などの文字列は、そのまま。これには以下の理由がある。

1. JSONに入れる時、生のバイト列を入れることができないから。

サイズ的に入らなくなればよりコンパクトなBase64を検討するが、今のところは大丈夫だろうと考えて進む(ハッシュ化をHexDigestで行う以上、統一した方がいい)

## 2.データフォーマット
### 登録リクエスト=送信側=
```json
{
   "data": {   # ← コロンはここ！
        "namespace": self.namespace,
        # json形式のためHex形式
        "pubkey": self.pubkey.hex()
    },
    "signature": self.signature.hex()
}
```
`data`と`signature`を分けているのは、受け取った側が署名検証対象のデータを取り出しやすくするため

また署名時はdata部分、
```json
"data": {   # ← コロンはここ！
        "namespace": self.namespace,
        # json形式のためHex形式
        "pubkey": self.pubkey.hex()
    },
```
を`utf-8`に変換して署名する。

これはjsonをそのまま扱うことができないから。

そして署名ができたら、署名もJSON形式の送信データに加える。この時`signature`も`Hex()`形式での送信になる。

最終的に送信するのは、

登録リクエスト全体を`utf-8`にしたものを送る。これはCefpycoの`msg_org`がjson形式での送信を想定していないから。

## 登録リクエスト=受信側=
受信側は以下の流れで署名検証やデータ取り出しをするものと想定できる
1. 受け取ったデータを`utf-8` -> `json`に変換
2. `data`部分の`pubkey`を取り出す。この時`pubkey:hex()`になっているので、`bytes.fromHex(pubkey)`でいける。
3. これでとれた`raw`形式のバイト列から
```py
pk = ed25519.Ed25519PublicKey.from_public_bytes(raw_pk)
```
にて公開鍵を生成
4. `data`部分を取り出し、`utf-8`に変換
5. `signature`部分を取り出して、こちらも`bytes.fromHex(signature)`で検証可能なバイト列に
6. `signature`バイト列と`data`の`utf-8`を用いて、以下を持って署名検証
```py
pk.verify(signature, data)
```
で署名検証をする。

# aries環境
## cefnetdが動かなくなる
Macだと事前にガベージコレクションしてから自動で実行してくれるが、Ubuntuのdockerだとそんなことはないらしく、事前に
```
# 停止中のコンテナを全部削除
docker container prune -f

# 使われていないネットワークを全部削除
docker network prune -f
```
を実行して前回使用したものを削除しておく必要がある。
しかし、ビルドキャッシュは残してくれているようで、これを実行しても作り直す際は高速でビルドしてくれる。
なのでそこまで実装に影響はしないと思われる。

# ログのとりかた
ログの取り方の模索には随分と迷ったが、これが正解であろうことを記述していく
1. docker-composeファイルを実行する(dockerfile側でログを取ったら自動でいけるようにしている)
詳細を言うと、ceforeから直接ログを取るのではなく、tcpdumpで取得したpcapログをwiresharkで読み込ませると言う形のようだ。
今のところはDockerfile側で
```Dockerfile
ENTRYPOINT ["bash", "-lc", "\
  cefnetdstart; \
  mkdir -p /logs; \
  tcpdump -i eth0 -nn -s0 -w ./bcnode1.pcap & \
  exec tail -f /dev/null \
"]
```
すなわち
```bash
tcpdump -i eth0 -nn -s0 -w ./<nodename>.pcap
```
※<nodename>はノード名で置き換え
と言うふうにして各ノードでログを取っている。
2.  Wireshark側で`cefore/apps/wireshark4cefore.lua`を読み込ませ、それを元にpcapファイルを解析すると、
ICN用に整形した解析結果を出してくれるようだが、未検証。
3. 

